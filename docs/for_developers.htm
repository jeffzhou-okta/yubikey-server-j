<pre>
<h2>WS-API documentation for developers</h2>

The WS-API is a Web Services API to do two things:

1. Manage YubiKeys/Clients

2. Verify OTPs from YubiKeys

For 1., all requests and responses are digitally signed. For 2., only responses are signed. More about how signatures are done and more on generic API usage can be found in the "api.html" file in this directory.

This document covers the internal structure of the implementation of WS-API.

1. Dependencies

WS-API builds with Apache ant. Any recent version should be ok.

WS-API works with both MySQL and PostgreSQL is work in progress. There are two databases
(regardles of RDBMS): the production one (called 'yubico') and the 
test one, called 'test_yubico'. 

Database username and passwords are communicated in the web.xml files.

Unit testing is done by "$ant test". For predictable tests, make
sure to reset the test database using one of the test_*.sql files
found in this directory.

All dependencies reside in /resources. build.properties has the mappings.
Some resources are only used during testing.

yubico_base_jar  Yubico java sdk found in CVS module 'java-sdk'.
tsik_jar         Apache TSIK, used for Base64 libraries
servlet_jar      J2EE servlets
log4j_jar        For all logging
junit_jar        Junit, for testing only
httpunit_jar     HTTP unit, for testing only
js_jar           js.jar, required by HTTPunit
mysql_jar or
postgres_jar     Database JDBC driver needed by the servlet 
                 container to connect the WS-API servlets with the database.


2. Database design

Policy: Nothing ever gets deleted from any table. When API calls are
used to 'delete' objects, these objects are merely flagged as inactive.
In this way, it is easy to maintain database integrity and make it
possoble for future 'undelete' API calls. It's also a good way to keep
all keying information so nothing is ever lost.

Three tables:

clients      Everyone that wants to use the management APIs need to
             be a client. A client has an API key used to sign all requests,
             and set of permissions that define what operations a client
             can perform (adding/deleting keys/clients).

perms        A set of permissions. Each client references a set.

yubikeys     A physical yubikey that is owned by a client. 


Client #1 is the root client owned by yubico. This should be the only
client with permission to add and delete other clients. All clients 
should thus be generated 




3. Deployment design

WS-API builds as a standard servlet that can be deployed in most
J2EE servlet container. Currently we've been using tomcat, but nothing
tomcat-specific is (intentionally) utilized by the code.

There are two servlets for each of the management and verification
usage request/response patterns. Each servlet uses this pattern to
handle requests:

a.  a request factory generates a request from the incoming message

b.  this request is constructed and pre-conditions related to what
    this message must contain are checked (in Request()'s constructor)

c.  process() is called on the request. This checks whether the
    request is properly signed and whether the client is permitted
    to perform the operation

d.  process() then performs the operation and creates a response,
    that will be signed at creation time

e.  the request factory then prints the response back on the caller's
    output stream


* Each request has its own class, generated by the request factory 
* Each response has its own class, generated by the request
* Signature verification is done by the request
* Signing is done by the response


4. Trace a request flow

User request comes into Ws-Api handler 

In Ws-Api
---------
Check validity of message {
  Parse message parts
}

If message is not valid {
  Create response
    r = one of the error as per table
    t = now
    h = sha-1 hmac of (r + t) if verifier's shared secret could be found
  Return response
}

Send OTP to key subsystem

In Key Subsystem (internal system only)
----------------

- Receive OTP
- Assume OTP contains yubikey identification. If not, Ws-Api 
  needs to supply this information.
- Look up yubikey shared secret
- Check OTP
- Return yes/no

Back to Ws-Api
--------------

Read response from Key Subsystem
Create response {
 r = status from key sub system
 t = now
 h = sha-1 hmac of (r + t) using verifier's secret as key
}
return response

(*) timestamp should be 'reasonable' (within some interval 
to allow for skew). We could collect timestamps to completely 
prevent replays.
