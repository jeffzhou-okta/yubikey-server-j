<h1>Yubico Web Service APIs</h1>

<p>The Yubico Web Service APIs make it possible for you to verify the
one-time passwords (OTP) generated by the YubiKey.  This page
describes how to get started working with our server, and also
provides the protocol specification.

<p>We have written clients in several languages and for different
purposes, so chances are that you do not need to implement our
protocol yourself.  Save your time
by <a href="/developers/clients/">reviewing our existing clients</a>.

<p>If you write a new client following these specifications,
please <a href="/contact/index/">let us know</a> so that others can
avoid duplicating work.

<h2>Getting started</h2>

Here is the quickest way to get started:

<dl>
<dt><a name="api_key"><b>1. API key</b></a></dt>

<dd>To use the API, send a mail
to <a href="mailto:tech@yubico.com">tech@yubico.com</a>.  When you do
this, we will assign you an ID and create a shared key.  You can use
the shared key to authenticate that the API responses do come from us,
if you for some reason do not want to rely on HTTPS.  You may also
sign requests using this key, so that we know who are sending
them.</dd>

<dt><b>2. Capture an OTP</b></dt>

<dd>Capture an OTP output from your YubiKey.  You can do that by
opening Notepad (for Windows), TextEdit (for Mac OS X) or Emacs (for
GNU/Linux) and simply pressing the button on the YubiKey.  The OTP is
a simple string of characters, like this:
<code>vvvvvvcurikvhjcvnlnbecbkubjvuittbifhndhn</code>.</dt>

<dt><b>3. Send OTP to our server</b></dt>

<dd>Make the authentication request against our server following the
protocol specified below.  Your request should include the verifier
ID, a number that identifies the approver of your key, and the OTP you
captured in the previous instruction.  The request is part of the HTTP
GET URL, encoded using normal parameter/value pairs.  For example:

<p><pre>
http://api.yubico.com/wsapi/verify?id=42&otp=vvvvvvcurikvhjcvnlnbecbkubjvuittbifhndhn
</pre>

</dd>

<dt><b>4. Parse response</b></dt>

<dd>You will recieve a response back from the server, a string of text
that resembles the following:

<p><pre>
h=hhbVQZYvkEWUdhYjx1hjB/yeW/Y=
t=2008-01-11T03:51:21Z0079
status=OK
</pre>

<p>You can check the authenticity of this response using the HMAC
specification detailed below.

<dt><b>5. Make a decision</b></dt>

<dd>Do what you wish with the information in the response,
specifically the section denoted with "status=" as this is the final
response.  All our APIs define constants related to these statuses,
also listed below.</dd>

</dl>

<h3>Protocol Specification</h3>

<p>All requests are HTTP GETs.  As such, all parameters must be
properly URL encoded.

<p>Each response sent by Yubico is signed.  To make sure the response
has not been tampered with, you should verify the signature.


<p>To verify a <a name="signatures">signature</a> on a message, follow
the same procedure that was used to <a href="#generate_sig">sign the
message</a> and compare the signature in the response to the signature
you generate generated.  If the signature values are equal, the
signature is correct.

Make sure you remove the signature itself from the values you generate
the signature over for verification. If the incoming message is
<pre>
b=1&a=2&c=3&h=V5FkMYr9GCG9tQA9ihuuybWl99U=
</pre>

make sure to remove <code>h</code> before verifying:
<pre>
b=1&a=2&c=3
</pre>

<h4 id="generate_sig">Generating signatures</h4>

<p>The Yubico API uses HMAC-SHA1 signatures with 160 bit key lengths
(as defined by <a href="http://www.ietf.org/rfc/rfc3174.txt">RFC
3174</a>).  The HMAC key to use is the <a href="#api_key">API key</a>.

<p>Generate the signature over the parameters in the message. Each
message contains a set of key/value pairs, and the signature is always
over the entire set (excluding the signature itself), sorted in
alphabetical order of the keys.

To generate a message signature:
<ol>
  <li>Alphabetically sort the set of key/value pairs by key order.</li>
  <li>Construct a single line with each ordered key/value pair concatenated
  using '&', and each key and value contatenated with '='. Do not add any
  linebreaks. Do not add whitespace. For
  example: <code>a=2&b=1&c=3</code>.</li>
  <li>Apply the signature algorithm to the line's octet string (UTF-8 byte
  values according to
  <a href="http://www.ietf.org/rfc/rfc3629.txt">RFC 3629</a>) using
  the
  <a href="#api_key">API key</a> as key.</li>
  <li>Base 64 encode the resulting value according to
  <a href="http://www.ietf.org/rfc/rfc4648.html">RFC 4648</a>, for
  example, <code>t2ZMtKeValdA+H0jVpj3LIichn4=</code>.</li>
  <li>Append the value under key <code>h</code> to the message.
</ol>

<!--
<h2>Manage keys</h2>
There are two calls to manage your keys: <code>add_key</code>, and
<code>delete_key</code>.

<h3><code>add_key</code></h3>
This API call adds a key so that you can later verify its OTPs.

<h4>Request</h4>
To add a key you'll construct an HTTP GET call to
<pre>
https://api.yubico.com/wsapi/add_key
</pre>
with the following parameters:
<br></br>
<table border=1>
  <th>parameter</th><th>type</th><th>required</th><th>purpose</th>
  <tr>
    <td><code>operation</code></td>
    <td>string; always <code>add_key</code></td>
    <td>Yes</td>
    <td>Specifies operation to the end-point</td>
  </tr>
  <tr>
    <td><code>id</code></td>
    <td>string</td>
    <td>Yes</td>
    <td>Specifies the requestor so that the end-point can retrieve
    correct shared secret</td>
  </tr>
  <tr>
    <td><code>nonce</code></td>
    <td>string</td>
    <td>Yes</td>
    <td>Adds cryptographic uniqueness to a message, and makes it possible
      to track request and response</td>
  </tr>
  <tr>
    <td><code>h</code></td>
    <td>string (base64)</td>
    <td>Yes</td>
    <td>Signature as <a href="#signatures">described above</a>.</td>
  </tr>
</table>
<br></br>
An example request (broken into two lines for legibility):
<pre>
https://api.yubico.com/wsapi/add_key?operation=add_key&non\
ce=1970-01-01T00%3A00%3A00Z1331&h=aFyeHAljexxyghLZq%2FoWjNnp%2B2s%3D&id=2
</pre>

<h4>Response</h4>
The response contains enough information for you to successfully
program a YubiKey with correct keying and identity information. More
on this (link TBD here).
<br></br>
The response has the following values:
<br></br>


<table border=1>
  <th>parameter</th><th>type</th><th>purpose</th>
  <tr>
    <td><code>h</code></td>
    <td>string (base64)</td>
    <td>Signature as <a href="#signatures">described above</a>.</td>
  </tr>
  <tr>
    <td><code>t</code></td>
    <td>time stamp</td>
    <td>Timestamp in UTC</td>
  </tr>
  <tr>
    <td><code>operation</code></td>
    <td>string; always <code>add_key</code></td>
    <td>Echoed from the request</td>
  </tr>
  <tr>
    <td><code>nonce</code></td>
    <td>string</td>
    <td>Echoed from the request</td>
  </tr>
  <tr>
    <td><code>shared_secret</code></td>
    <td>string (base64)</td>
    <td>The key inside the YubiKey.</td>
  </tr>
  <tr>
    <td><code>user_id</code></td>
    <td>string (base64)</td>
    <td>The internal key ID.</td>
  </tr>
  <tr>
    <td><code>token_id</code></td>
    <td>string (base64)</td>
    <td>The external key ID.</td>
  </tr>
  <tr>
    <td><code>status</code></td>
    <td>string (base64)</td>
    <td>The status of the operation. The status are described
      in <a href="#add_key_return_codes">return codes</a>.</td>
  </tr>
  <tr>
    <td><code>info</code></td>
    <td>string</td>
    <td>Additional information if the status
      is <code>MISSING_PARAMETER</code>.</td>
  </tr>
</table>

<h4 id="add_key_return_codes">Return codes</h4>
These are possible <code>status</code> values in an <code>add_key</code>
response:
<table border=1>
  <th>name</th><th>meaning</th>
  <tr>
    <td><code>OK</code></td>
    <td>The request went through okay.</td>
  </tr>
  <tr>
    <td><code>MISSING_PARAMETER</code></td>
    <td>The request lacks parameter given by key <code>info</code>.</td>
  </tr>
  <tr>
    <td><code>NO_SUCH_CLIENT</code></td>
    <td>The request <code>id</code> does not exist.</td>
  </tr>
  <tr>
    <td><code>BAD_SIGNATURE</code></td>
    <td>The request signature does not verify.</td>
  </tr>
  <tr>
    <td><code>OPERATION_NOT_ALLOWED</code></td>
    <td>The request <code>id</code> is not allowed to add keys.</td>
  </tr>
  <tr>
    <td><code>BACKEND_ERROR</code></td>
    <td>Unexpected error in our server. Please contact us if you see this
      error.</td>
  </tr>
</table>


<h3><code>delete_key</code></h3>
This API call deletes a key from the backend. You can no more verify
a deleted key's OTPs.

<h4>Request</h4>
To delete a key you'll construct an HTTP GET call to
<pre>
https://api.yubico.com/wsapi/delete_key
</pre>
with the following parameters:
<br></br>

<table border=1>
  <th>parameter</th><th>type</th><th>required</th><th>purpose</th>
  <tr>
    <td><code>operation</code></td>
    <td>string; always <code>delete_key</code></td>
    <td>Yes</td>
    <td>Specifies operation to the end-point</td>
  </tr>
  <tr>
    <td><code>id</code></td>
    <td>string</td>
    <td>Yes</td>
    <td>Specifies the requestor so that the end-point can retrieve
    correct shared secret and verify request.</td>
  </tr>
  <tr>
    <td><code>key_id</code></td>
    <td>string</td>
    <td>Yes</td>
    <td>Specifies the key to delete. This is the value previously returned
    via the <code>add_key</code> response's <code>token_id</code>.</td>
  </tr>
  <tr>
    <td><code>nonce</code></td>
    <td>string</td>
    <td>Yes</td>
    <td>Adds cryptographic uniqueness to a message, and makes it possible
      to track request and response</td>
  </tr>
  <tr>
    <td><code>h</code></td>
    <td>string (base64)</td>
    <td>Yes</td>
    <td>Signature as <a href="#signatures">described above</a>.</td>
  </tr>
</table>
<br></br>
An example request (broken into two lines for legibility):
<pre>
https://api.yubico.com/wsapi/delete_key?operation=delete_key&nonce=1970-01-\
01T00%3A00%3A00Z&h=gtPVOmd%2BW68O%2FmssjMCGEzY%2F4Ec%3D&key_id=NJrs7P1N&id=2
</pre>

<h4>Response</h4>
The response lets you know whether the request succeeded.
<br></br>
The response has the following values:
<br></br>

<table border=1>
  <th>parameter</th><th>type</th><th>purpose</th>
  <tr>
    <td><code>h</code></td>
    <td>string (base64)</td>
    <td>Signature as <a href="#signatures">described above</a>.</td>
  </tr>
  <tr>
    <td><code>t</code></td>
    <td>time stamp</td>
    <td>Timestamp in UTC</td>
  </tr>
  <tr>
    <td><code>operation</code></td>
    <td>string; always <code>delete_key</code></td>
    <td>Echoed from the request</td>
  </tr>
  <tr>
    <td><code>nonce</code></td>
    <td>string</td>
    <td>Echoed from the request</td>
  </tr>
  <tr>
    <td><code>key_id</code></td>
    <td>string (base64)</td>
    <td>Echoed from the request</td>
  </tr>
  <tr>
    <td><code>status</code></td>
    <td>string (base64)</td>
    <td>The status of the operation. The status are described
      in <a href="#delete_key_return_codes">return codes</a>.</td>
  </tr>
  <tr>
    <td><code>info</code></td>
    <td>string</td>
    <td>Additional information if the status
      is <code>MISSING_PARAMETER</code>.</td>
  </tr>
</table>

<h4 id="delete_key_return_codes">Return codes</h4>
These are possible <code>status</code> values in a <code>delete_key</code>
response:
<table border=1>
  <th>name</th><th>meaning</th>
  <tr>
    <td><code>OK</code></td>
    <td>The request went through okay.</td>
  </tr>
  <tr>
    <td><code>MISSING_PARAMETER</code></td>
    <td>The request lacks parameter given by key <code>info</code>.</td>
  </tr>
  <tr>
    <td><code>NO_SUCH_CLIENT</code></td>
    <td>The request <code>id</code> does not exist.</td>
  </tr>
  <tr>
    <td><code>NO_SUCH_YUBIKEY</code></td>
    <td>The request <code>key_id</code> does not exist.</td>
  </tr>
  <tr>
    <td><code>BAD_SIGNATURE</code></td>
    <td>The request signature does not verify.</td>
  </tr>
  <tr>
    <td><code>OPERATION_NOT_ALLOWED</code></td>
    <td>The request <code>id</code> is not allowed to delete keys.</td>
  </tr>
  <tr>
    <td><code>BACKEND_ERROR</code></td>
    <td>Unexpected error in our server. Please contact us if you see this
      error.</td>
  </tr>
</table>

-->

<h2>Verification</h2>
There is one call to verify YubiKey OTPs: <code>verify</code>.

<h3>verify</h3>
The <code>verify</code> call lets you check whether an OTP is valid. Since the
OTP itself contains identification information, all you have to do
is to send the OTP.

<h4>Request</h4>
Construct an HTTP GET call to
<pre>
http://api.yubico.com/wsapi/verify
</pre>
with the following parameters (note that this request need not be signed):
<br></br>
<table border=1>
  <th>parameter</th><th>type</th><th>required</th><th>purpose</th>
  <tr>
    <td><code>id</code></td>
    <td>string</td>
    <td>Yes</td>
    <td>Specifies the requestor so that the end-point can retrieve
    correct shared secret for signing the response.</td>
  </tr>
  <tr>
    <td><code>otp</code></td>
    <td>string</td>
    <td>Yes</td>
    <td>The OTP from the YubiKey.</td>
  </tr>
</table>
<br></br>
An example request (broken into two lines for legibility):
<pre>
http://api.yubico.com/wsapi/verify?otp=vvvvvvcucrlcietctc\
kflvnncdgckubflugerlnr&id=87 
</pre>

<h4>Response</h4>
The verification response tells you whether the OTP is valid.
<br></br>
The response has the following values:
<br></br>

<table border=1>
  <th>parameter</th><th>type</th><th>purpose</th>
  <tr>
    <td><code>h</code></td>
    <td>string (base64)</td>
    <td>Signature as <a href="#signatures">described above</a>.</td>
  </tr>
  <tr>
    <td><code>t</code></td>
    <td>time stamp</td>
    <td>Timestamp in UTC.</td>
  </tr>
  <tr>
    <td><code>status</code></td>
    <td>string (base64)</td>
    <td>The status of the operation. The status are described
      in <a href="#verify_return_codes">return codes</a>.</td>
  </tr>
  <tr>
    <td><code>info</code></td>
    <td>string</td>
    <td>Additional information if the status
      is <code>MISSING_PARAMETER</code>.</td>
  </tr>
</table>


<h4 id="verify_return_codes">Return codes</h4>
These are possible <code>status</code> values in a <code>verify</code>
response:
<table border=1>
  <th>name</th><th>meaning</th>
  <tr>
    <td><code>OK</code></td>
    <td>The OTP is valid.</td>
  </tr>
  <tr>
    <td><code>BAD_OTP</code></td>
    <td>The OTP is invalid format.</td>
  </tr>
  <tr>
    <td><code>REPLAYED_OTP</code></td>
    <td>The OTP has already been seen by the service.</td>
  </tr>
  <tr>
    <td><code>MISSING_PARAMETER</code></td>
    <td>The request lacks parameter given by key <code>info</code>.</td>
  </tr>
  <tr>
    <td><code>NO_SUCH_CLIENT</code></td>
    <td>The request <code>id</code> does not exist.</td>
  </tr>
  <tr>
    <td><code>OPERATION_NOT_ALLOWED</code></td>
    <td>The request <code>id</code> is not allowed to verify OTPs.</td>
  </tr>
  <tr>
    <td><code>BACKEND_ERROR</code></td>
    <td>Unexpected error in our server. Please contact us if you see this
      error.</td>
  </tr>
</table>

